<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Blog by jhz-lihuaxin</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">spring事务总结</h1>
      <h2 class="project-tagline"></h2>
      <!-- <a href="https://github.com/jhz-lihuaxin/blog" class="btn">View on GitHub</a>
      <a href="https://github.com/jhz-lihuaxin/blog/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/jhz-lihuaxin/blog/tarball/master" class="btn">Download .tar.gz</a> -->
    </section>

    <section class="main-content">
    <!-- <h3>
          <a id="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages" aria-hidden="true">
            <span aria-hidden="true" class="octicon octicon-link"></span>
          </a>
    第一部分标题
    </h3> -->

    <p>
       一、事务：指逻辑上的一组操作，这组操作要么全部成功，要么全部失败</br>
    </p>
    <p>
       二、事务的特性：</br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、原子性：不可分割的工作单位。</br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、一致性：指事务前后数据的完整性保持一致</br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、隔离性：多个用户并发访问数据库时，事务彼此之间要相互隔离，不被干扰</br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、持久性：事务被提交，记录就被真正修改到数据库中</br>
    </p>
    <p>
       三、Spring中一组管理事务接口：</br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、PlatformTransactionManager：事务管理器（提交 、 回滚）</br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、TransactionDefinition：事务定义信息（隔离、事务传播行为、超时、只读）</br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、TransactionStatus：事务具体运行状态</br>
    </p>
    <p>
      四、Spring事务的隔离级别</br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、ISOLATION_DEFAULT:这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别.
                                              另外四个与JDBC的隔离级别相对应</br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、ISOLATION_READ_UNCOMMITTED:这是事务最低的隔离级别，它充许令外一个事务可以看到这个事务未提交的数据。
                                              这种隔离级别会产生脏读，不可重复读和幻像读。</br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、ISOLATION_READ_COMMITTED:保证一个事务修改的数据提交后才能被另外一个事务读取。
                                              另外一个事务不能读取该事务未提交的数据</br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、ISOLATION_REPEATABLE_READ： 这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。
                                              它除了保证一个事务不能读取另一个事务未提交的数据外，还保证了避免下面的情况产生(不可重复读)。</br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5、ISOLATION_SERIALIZABLE 这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。
                                              除了防止脏读，不可重复读外，还避免了幻像读。</br>
    </p>  
    <p>
      六、隔离级别解决的问题：</br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、脏读：一个事务读取了另一个事务改写但还未提交的数据，如果这些数据被回滚，则读到的数据是无效的</br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、不可重复读：在同一个事务中，读取到了另一个事务已经更新（update）的数据导致多次的查询结果不一致。</br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、幻读：多次读取，发现了原来没有的数据（就是被insert进去的数据）。</br>
    </p>
    <p>
      七、事务的传播行为：事务的控制是放在业务层，传播行为主要就是解决多业务间相互调用的问题。</br> 
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1、支持当前事务，如果不存在就建一个事务：PROPAGATION_REQUIRED</br>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2、支持当前事务，如果不存在，就不使用事务：PROPAGTION_SUPPORTS</br>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3、支持当前事务，如果不存在，抛出异常：PROPAGTION_MANDATORY说的就是多个业务相互调用是在同一个事务中运行</br>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;4、存在事务，挂起当前事务，创建一个新事务：PROPAGATION_REQUIRES_NEW</br>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5、以非事务方式运行，存在事务，挂起当前事务：PROPAGATION_NOT_SUPPORTED</br>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;6、以非事务方式运行，存在事务，抛出异常：PROPAGATION_NEVER说的就是多个业务间相互调用，不在同一个事务里 </br>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7、如果当前事务存在，则嵌套事务执行：PROPAGTION_NESTED说的是对当前业务的事务做一个事务保存点，在之后调用其他业务时，假如发生异常，可以回滚到保存点也可以回滚到初始状态。</br>
    </p>
    <p>
      八、Spring事务管理的方式：</br>
         &nbsp;&nbsp;&nbsp;--编程式的事务管理（不多说）</br>
         &nbsp;&nbsp;&nbsp;--声明式事务管理：（分为三种）</br>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;依赖TransactionProxyFactoryBean对需要进行事务管理的业务类进行代理，便于实施事务功能的增强</br>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;缺点：针对每一个需要事务管理的业务类都需要配置相应的事务管理</br>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过AOP实现的，面向切面的编程开发，提供通配符方式配置需要事务管理的业务</br>
         &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;注解方式实现事务管理  </p>
    </p>
    <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/jhz-lihuaxin/blog">Blog</a> is maintained by <a href="https://github.com/jhz-lihuaxin">jhz-lihuaxin</a>.</span>

        <!-- <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span> -->
    </footer>

    </section>
  </body>
</html>
